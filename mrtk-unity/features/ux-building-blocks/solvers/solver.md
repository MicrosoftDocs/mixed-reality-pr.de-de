---
title: Solver-Übersicht
description: Übersicht über Solver in MRTK
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, Entwicklung, MRTK, PR, Solver,
ms.openlocfilehash: bf9bbfe578ace576fca8870f038f145037a6838d
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176452"
---
# <a name="solver-overview"></a><span data-ttu-id="83f9d-104">Solver-Übersicht</span><span class="sxs-lookup"><span data-stu-id="83f9d-104">Solver overview</span></span>

![Solver Main](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="83f9d-106">Solver sind Komponenten, die die Berechnung der Position und Ausrichtung eines Objekts gemäß einem vordefinierten Algorithmus erleichtern.</span><span class="sxs-lookup"><span data-stu-id="83f9d-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="83f9d-107">Ein Beispiel hierfür ist das Platzieren eines Objekts auf der Oberfläche, auf die der Raycast des Anvisierens durch den Benutzer aktuell trifft.</span><span class="sxs-lookup"><span data-stu-id="83f9d-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="83f9d-108">Darüber hinaus definiert das Solver-System deterministisch eine Reihenfolge von Vorgängen für diese Transformationsberechnungen, da es keine zuverlässige Möglichkeit gibt, Unity die Aktualisierungsreihenfolge für Komponenten anzugeben.</span><span class="sxs-lookup"><span data-stu-id="83f9d-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="83f9d-109">Solver bieten eine Reihe von Verhaltensweisen zum Anfügen von Objekten an andere Objekte oder Systeme.</span><span class="sxs-lookup"><span data-stu-id="83f9d-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="83f9d-110">Ein weiteres Beispiel wäre ein mitwanderndes Objekt, das vor dem Benutzer schwebt (basierend auf der Kamera).</span><span class="sxs-lookup"><span data-stu-id="83f9d-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="83f9d-111">Ein Solver könnte auch an einen Controller und ein Objekt angefügt werden, damit das Objekt dem Controller folgt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="83f9d-112">Alle Solver können sicher gestapelt werden, z. B. ein Folgeverhalten + Oberflächenmagnetismus + Momentum.</span><span class="sxs-lookup"><span data-stu-id="83f9d-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="83f9d-113">Verwenden eines Solvers</span><span class="sxs-lookup"><span data-stu-id="83f9d-113">How to use a solver</span></span>

<span data-ttu-id="83f9d-114">Das Solver-System besteht aus drei Kategorien von Skripts:</span><span class="sxs-lookup"><span data-stu-id="83f9d-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="83f9d-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): Die abstrakte Basisklasse, von der alle Solver abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="83f9d-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="83f9d-116">Sie bietet Zustandsverfolgung, Glättungsparameter und Implementierung, automatische Solver-Systemintegration und Aktualisierungsreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="83f9d-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="83f9d-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Legt das zu verfolgende Bezugsobjekt fest (z. B. die Hauptkameratransformation, Handstrahl usw.), verarbeitet das Sammeln von Solver-Komponenten und führt deren Aktualisierung in der richtigen Reihenfolge aus.</span><span class="sxs-lookup"><span data-stu-id="83f9d-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="83f9d-118">Die dritte Kategorie ist der Solver selbst.</span><span class="sxs-lookup"><span data-stu-id="83f9d-118">The third category is the solver itself.</span></span> <span data-ttu-id="83f9d-119">Die folgenden Solver stellen die Bausteine für das grundlegende Verhalten bereit:</span><span class="sxs-lookup"><span data-stu-id="83f9d-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="83f9d-120">[`Orbital`](#orbital): Wird an einer angegebenen Position und mit einem Offset vom Bezugszobjekt verankert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="83f9d-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Wird so skaliert, dass eine konstante Größe relativ zur Ansicht des Bezugsobjekts beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="83f9d-122">[`RadialView`](#radialview): Hält das Objekt innerhalb eines Sichtkegels, der vom Bezugsobjekt geworfen wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="83f9d-123">[`Follow`](#follow): Hält das Objekt innerhalb einer Gruppe benutzerseitig definierter Grenzen vom Bezugsobjekt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="83f9d-124">[`InBetween`](#inbetween): Hält ein Objekt zwischen zwei verfolgten Objekten.</span><span class="sxs-lookup"><span data-stu-id="83f9d-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="83f9d-125">[`SurfaceMagnetism`](#surfacemagnetism): Wirft Strahlen auf Oberflächen in der Welt und richtet das Objekt an dieser Oberfläche aus.</span><span class="sxs-lookup"><span data-stu-id="83f9d-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="83f9d-126">[`DirectionalIndicator`](#directionalindicator): Bestimmt die Position und Ausrichtung eines Objekts als Richtungsindikator.</span><span class="sxs-lookup"><span data-stu-id="83f9d-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="83f9d-127">Ab dem Bezugspunkt des vom SolverHandler verfolgten Ziels richtet sich dieser Indikator auf das angegebene DirectionalTarget aus.</span><span class="sxs-lookup"><span data-stu-id="83f9d-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="83f9d-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Wendet Beschleunigung/Geschwindigkeit/Reibung an, um Momentum und Elastizität für ein Objekt zu simulieren, das von anderen Solvern/Komponenten bewegt wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="83f9d-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Schränkt das Objekt auf die Verfolgung von Händen in einem Bereich ein, in dem sich das GameObject nicht mit den Händen überschneidet.</span><span class="sxs-lookup"><span data-stu-id="83f9d-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="83f9d-130">Nützlich für auf Hände eingeschränkte interaktive Inhalte wie Menüs usw. Dieser Solver ist für die Verwendung mit [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) vorgesehen, funktioniert aber auch mit [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span><span class="sxs-lookup"><span data-stu-id="83f9d-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="83f9d-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Wird von HandConstraint abgeleitet, umfasst aber Logik zum Testen vor der Aktivierung, ob die Handfläche dem Benutzer zugewandt ist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="83f9d-132">Dieser Solver funktioniert nur mit [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand)-Controllern. Mit anderen Controllertypen verhält sich dieser Solver genau wie seine Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="83f9d-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="83f9d-133">Um das Solver-System zu verwenden, fügen Sie einem GameObject einfach eine der oben aufgeführten Komponenten hinzu.</span><span class="sxs-lookup"><span data-stu-id="83f9d-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="83f9d-134">Da alle Solver einen [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) erfordern, wird einer automatisch von Unity erstellt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="83f9d-135">Beispiele für die Verwendung des Solver-Systems finden Sie in der Datei **SolverExamples.scene**.</span><span class="sxs-lookup"><span data-stu-id="83f9d-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="83f9d-136">Ändern des Verfolgungsbezugs</span><span class="sxs-lookup"><span data-stu-id="83f9d-136">How to change tracking reference</span></span>

<span data-ttu-id="83f9d-137">Die Eigenschaft *Tracked Target Type* (Typ des verfolgten Ziels) der [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)-Komponente definiert den Bezugspunkt, den alle Solver verwenden, um ihre Algorithmen zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="83f9d-138">Beispielsweise führt ein Werttyp von [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) mit einer einfachen [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism)-Komponente zu einem Raycast vom Kopf des Benutzers aus und in dessen Anvisierrichtung, um aufzulösen, welche Oberfläche getroffen wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="83f9d-139">Potenzielle Werte für die `TrackedTargetType`-Eigenschaft sind:</span><span class="sxs-lookup"><span data-stu-id="83f9d-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="83f9d-140">*Head* (Kopf): Bezugspunkt ist die Transformation der Hauptkamera.</span><span class="sxs-lookup"><span data-stu-id="83f9d-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="83f9d-141">*ControllerRay* (Controllerstrahl): Bezugspunkt ist die [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer)-Transformation auf einem Controller (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="83f9d-142">der Zeigerursprung auf einem Motion-Controller oder Handcontroller), der in Richtung des Linienstrahls zeigt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="83f9d-143">Verwenden Sie die `TrackedHandedness`-Eigenschaft, um die bevorzugte Händigkeit auszuwählen (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="83f9d-144">links, rechts, beides).</span><span class="sxs-lookup"><span data-stu-id="83f9d-144">Left, Right, Both)</span></span>
* <span data-ttu-id="83f9d-145">*HandJoint* (Handgelenk): Bezugspunkt ist die Transformation eines spezifischen Handgelenks.</span><span class="sxs-lookup"><span data-stu-id="83f9d-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="83f9d-146">Verwenden Sie die `TrackedHandedness`-Eigenschaft, um die bevorzugte Händigkeit auszuwählen (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="83f9d-147">links, rechts, beides).</span><span class="sxs-lookup"><span data-stu-id="83f9d-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="83f9d-148">Verwenden sie die `TrackedHandJoint`-Eigenschaft, um die zu verwendende Gelenktransformation zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="83f9d-149">*CustomOverride* (benutzerdefinierte Außerkraftsetzung): Bezugspunkt von der zugewiesenen `TransformOverride` aus.</span><span class="sxs-lookup"><span data-stu-id="83f9d-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="83f9d-150">Für beide Typen, also *ControllerRay* und *HandJoint*, versucht der Solver-Handler zuerst, die linke Controller-/Handtransformation bereitzustellen, und dann die rechte, wenn die erste nicht verfügbar ist, oder wenn die `TrackedHandedness`-Eigenschaft etwas anderes angibt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="83f9d-151">![Solver Tracked Object (vom Solver verfolgtes Objekt)](../../images/solver/TrackedObjectType-Example.gif) 
*Beispiel für verschiedene Eigenschaften, die dem jeweiligen TrackedTargetType zugewiesen sind.*</span><span class="sxs-lookup"><span data-stu-id="83f9d-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="83f9d-152">Die meisten Solver verwenden den Vorwärtsvektor des verfolgten Transformationsziels, das vom `SolverHandler` bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="83f9d-153">Bei Verwendung des Typs *Handgelenk* für ein verfolgtes Ziel kann es sein, dass der Vorwärtsvektor des Hand(flächen)gelenks durch die Finger und nicht durch die Handfläche zeigt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="83f9d-154">Dies hängt von der Plattform ab, die die Handgelenksdaten liefert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="83f9d-155">Für die Eingabesimulation und Windows Mixed Reality ist es der *Nach-oben-Vektor*, der durch die Handfläche nach oben zeigt (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="83f9d-156">grüner Vektor zeigt nach oben, blauer Vektor vorwärts).</span><span class="sxs-lookup"><span data-stu-id="83f9d-156">green vector is up, blue vector is forward).</span></span>
>
> ![Vorwärtsvektor](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="83f9d-158">Um dies zu umgehen, aktualisieren Sie die Eigenschaft *Additional Rotation* (Zusätzliche Drehung) des `SolverHandler` auf **<90, 0, 0>** .</span><span class="sxs-lookup"><span data-stu-id="83f9d-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="83f9d-159">Dadurch wird sichergestellt, dass der an Solver übergebene Vorwärtsvektor durch die Handfläche und nach außen, von der Hand weg verweist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![Zusätzliche Drehung](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="83f9d-161">Alternativ können Sie den Typ *Controller Ray* (Controllerstrahl) für ein verfolgtes Ziel verwenden, um ein ähnliches Verhalten für das Zeigen mit den Händen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="83f9d-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="83f9d-162">Verketten von Solvern</span><span class="sxs-lookup"><span data-stu-id="83f9d-162">How to chain solvers</span></span>

<span data-ttu-id="83f9d-163">Es ist möglich, dem selben GameObject mehrere `Solver`-Komponenten hinzuzufügen und so deren Algorithmen zu verketten.</span><span class="sxs-lookup"><span data-stu-id="83f9d-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="83f9d-164">Die `SolverHandler`-Komponenten aktualisieren alle Solver desselben GameObject.</span><span class="sxs-lookup"><span data-stu-id="83f9d-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="83f9d-165">Standardmäßig ruft der `SolverHandler` beim Starten `GetComponents<Solver>()` auf, wodurch die Solver in der Reihenfolge zurückgegeben werden, in der sie im Inspektor vorkommen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="83f9d-166">Darüber hinaus weist das Festlegen der Eigenschaft *Updated Linked Transform* (Aktualisierte verknüpfte Transformation) auf „true“ den `Solver` an, seine berechnete Position, Ausrichtung und Skalierung in einer Zwischenvariablen zu speichern, auf die alle Solver zugreifen können (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="83f9d-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="83f9d-167">`GoalPosition`).</span></span> <span data-ttu-id="83f9d-168">„false“ gibt an, dass der `Solver` die Transformation des GameObject direkt aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="83f9d-169">Durch das Speichern der Transformationseigenschaften an einem Zwischenspeicherort können andere Solver ihre Berechnungen ab der Zwischenvariablen ausführen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="83f9d-170">Dies liegt daran, dass Unity nicht zulässt, dass Aktualisierungen von „gameObject.transform“ innerhalb desselben Frames gestapelt werden.</span><span class="sxs-lookup"><span data-stu-id="83f9d-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="83f9d-171">Entwickler können die Ausführungsreihenfolge von Solvern ändern, indem sie die `SolverHandler.Solvers`-Eigenschaft direkt festlegen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="83f9d-172">Erstellen eines neuen Solvers</span><span class="sxs-lookup"><span data-stu-id="83f9d-172">How to create a new solver</span></span>

<span data-ttu-id="83f9d-173">Alle Solver müssen von der abstrakten Basisklasse [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver) erben.</span><span class="sxs-lookup"><span data-stu-id="83f9d-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="83f9d-174">Die primären Anforderungen einer Solver-Erweiterung umfassen das Außerkraftsetzen der `SolverUpdate`-Methode.</span><span class="sxs-lookup"><span data-stu-id="83f9d-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="83f9d-175">Bei dieser Methode sollten Entwickler die geerbten Eigenschaften `GoalPosition`, `GoalRotation` und `GoalScale` auf die gewünschten Werte aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="83f9d-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="83f9d-176">Darüber hinaus ist es im Allgemeinen nützlich, `SolverHandler.TransformTarget` als Bezugsframe zu nutzen, der vom Consumer gewünscht wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="83f9d-177">Der unten angegebene Code enthält ein Beispiel für eine neue Solver-Komponente namens `InFront`, die das angefügte Objekt 2 m vor dem `SolverHandler.TransformTarget` platziert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="83f9d-178">Wenn der `SolverHandler.TrackedTargetType` vom Consumer als [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) festgelegt wird, ist `SolverHandler.TransformTarget` die Kameratransformation, weshalb dieser Solver dann das angefügte GameObject in jedem Frame 2 m vor dem Anvisieren des Benutzers platziert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="83f9d-179">Richtlinien für die Solver-Implementierung</span><span class="sxs-lookup"><span data-stu-id="83f9d-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="83f9d-180">Allgemeine Solver-Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="83f9d-180">Common solver properties</span></span>

<span data-ttu-id="83f9d-181">Jede Solver-Komponente verfügt über einen Kernsatz identischer Eigenschaften, die das Kernverhalten des Solvers steuern.</span><span class="sxs-lookup"><span data-stu-id="83f9d-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="83f9d-182">Wenn *Smoothing* (Glättung) aktiviert ist, aktualisiert der Solver die Transformation des GameObject im Laufe der Zeit schrittweise auf die berechneten Werte.</span><span class="sxs-lookup"><span data-stu-id="83f9d-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="83f9d-183">Die Geschwindigkeit dieser Änderung wird durch die Eigenschaft *LerpTime* der jeweiligen Transformationskomponente bestimmt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="83f9d-184">Ein höherer *MoveLerpTime*-Wert führt beispielsweise zu langsameren Inkrementen bei der Bewegung zwischen Frames.</span><span class="sxs-lookup"><span data-stu-id="83f9d-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="83f9d-185">Wenn *MaintainScale* aktiviert ist, verwendet der Solver die lokale Standardskalierung des GameObject.</span><span class="sxs-lookup"><span data-stu-id="83f9d-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="83f9d-186">![Solver-Kerneigenschaften](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="83f9d-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="83f9d-187">*Allgemeine Eigenschaften, die von allen Solver-Komponenten geerbt werden*</span><span class="sxs-lookup"><span data-stu-id="83f9d-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="83f9d-188">Orbital</span><span class="sxs-lookup"><span data-stu-id="83f9d-188">Orbital</span></span>

<span data-ttu-id="83f9d-189">Die [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital)-Klasse ist eine Komponente mit Folgeverhalten, die sich wie Planeten in einem Sonnensystem verhält.</span><span class="sxs-lookup"><span data-stu-id="83f9d-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="83f9d-190">Dieser Solver stellt sicher, dass das angefügte GameObject die verfolgte Transformation umkreist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="83f9d-191">Wenn also der *Tracked Target Type* (Typ des verfolgten Ziels) des [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) auf [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) festgelegt ist, umkreist das GameObject den Kopf des Benutzers mit einem festen Offset.</span><span class="sxs-lookup"><span data-stu-id="83f9d-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="83f9d-192">Entwickler können diesen festen Offset ändern, um Menüs oder andere Szenenkomponenten auf Augen- oder Hüfthöhe usw. um einen Benutzer herum zu halten.</span><span class="sxs-lookup"><span data-stu-id="83f9d-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="83f9d-193">Dies erfolgt durch Ändern der Eigenschaften *Local Offset* (Lokaler Offset) und *World Offset* (Weltoffset).</span><span class="sxs-lookup"><span data-stu-id="83f9d-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="83f9d-194">Die Eigenschaft *Orientation Type* (Ausrichtungstyp) bestimmt auf das Objekt angewendete Drehung, ob es seine ursprüngliche Drehung beibehalten oder immer der Kamera oder dem Gesicht zugewandt sein soll, egal welche Transformation seine Position bestimmt usw.</span><span class="sxs-lookup"><span data-stu-id="83f9d-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="83f9d-195">![Orbital-Beispiel](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="83f9d-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="83f9d-196">*Orbital-Beispiel*</span><span class="sxs-lookup"><span data-stu-id="83f9d-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="83f9d-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="83f9d-197">RadialView</span></span>

<span data-ttu-id="83f9d-198">[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) ist eine weitere Komponente mit Folgeverhalten, die einen bestimmten Teil eines GameObject im Frustum des Sichtfelds des Benutzers hält.</span><span class="sxs-lookup"><span data-stu-id="83f9d-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="83f9d-199">Die Eigenschaften *Min & Max View Degrees* (Mindest-/Maximalsichtgrad) bestimmen die Größe des Teils des GameObject, der immer im Sichtfeld sein muss.</span><span class="sxs-lookup"><span data-stu-id="83f9d-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="83f9d-200">Die Eigenschaften *Min & Max Distance* (Mindest-/Maximalabstand) bestimmen, wie weit das GameObject vom Benutzer entfernt bleiben soll.</span><span class="sxs-lookup"><span data-stu-id="83f9d-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="83f9d-201">Wenn Sie beispielsweise mit einer *Min Distance* (Mindestabstand) von 1 m auf das GameObject zugehen, wird das GameObject weggestoßen, um sicherzustellen, dass es dem Benutzer nie näher als 1 m kommt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="83f9d-202">Im Allgemeinen wird die [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) in Verbindung mit dem auf [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) festgelegten *Tracked Target Type* (Typ des verfolgten Ziels) verwendet, damit die Komponente dem Anvisieren des Benutzers folgt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="83f9d-203">Diese Komponente kann jedoch so funktionieren, dass sie immer im *"Sichtfeld"* jedes *Tracked Target Type* (Typ des verfolgten Ziels) gehalten wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="83f9d-204">![RadialView-Beispiel](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="83f9d-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="83f9d-205">*RadialView-Beispiel*</span><span class="sxs-lookup"><span data-stu-id="83f9d-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="83f9d-206">Follow</span><span class="sxs-lookup"><span data-stu-id="83f9d-206">Follow</span></span>

<span data-ttu-id="83f9d-207">Die [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow)-Klasse positioniert ein Element vor dem verfolgten Ziel, relativ zu seiner lokalen Vorwärtsachse.</span><span class="sxs-lookup"><span data-stu-id="83f9d-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="83f9d-208">Das Element kann lose eingeschränkt werden (auch als</span><span class="sxs-lookup"><span data-stu-id="83f9d-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="83f9d-209">Folgeverhalten („tag-along“) bezeichnet), sodass es erst dann folgt, wenn das verfolgte Ziel benutzerdefinierte Grenzen überschreitet.</span><span class="sxs-lookup"><span data-stu-id="83f9d-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="83f9d-210">Es funktioniert ähnlich wie der RadialView-Solver mit zusätzlichen Steuerelementen zum Verwalten von *Max Horizontal & Vertical View Degrees* (Max. horizontale/vertikaler Sichtgrad) und Mechanismen zum Ändern der *Ausrichtung* des Objekts.</span><span class="sxs-lookup"><span data-stu-id="83f9d-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="83f9d-211">![Follow-Eigenschaften](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="83f9d-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="83f9d-212">*Follow-Eigenschaften*</span><span class="sxs-lookup"><span data-stu-id="83f9d-212">*Follow properties*</span></span>

<span data-ttu-id="83f9d-213">![Follow-Beispielszene](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="83f9d-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="83f9d-214">*Follow-Beispielszene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="83f9d-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="83f9d-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="83f9d-215">InBetween</span></span>

<span data-ttu-id="83f9d-216">Die [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween)-Klasse hält das angefügte GameObject zwischen zwei Transformationen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="83f9d-217">Diese zwei Transformationsendpunkte werden durch den eigenen *Tracked Target Type* (Typ des verfolgten Ziels) [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) des GameObject und die Eigenschaft *Second Tracked Target Type* (Zweiter Typ des verfolgten Ziels) der [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween)-Komponente definiert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="83f9d-218">Im Allgemeinen werden beide Typen auf [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) und die resultierenden `SolverHandler.TransformOverride`- und `InBetween.SecondTransformOverride`-Werte auf die zwei verfolgten Endpunkte festgelegt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="83f9d-219">Zur Laufzeit erstellt die [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween)-Komponente eine weitere [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)-Komponente, die auf den Eigenschaften *Second Tracked Target Type* (Zweiter Typ des verfolgten Ziels) und *Second Transform Override*(Zweite Transformationsaußerkraftsetzung) basiert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="83f9d-220">Der `PartwayOffset` definiert, wo entlang der Linie zwischen zwei Transformationen das Objekt platziert werden soll, wobei 0,5 auf halber Strecke, 1,0 bei der ersten Transformation und 0,0 bei der zweiten Transformation ist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="83f9d-221">![InBetween-Beispiel](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="83f9d-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="83f9d-222">*Beispiel für die Verwendung des InBetween-Solvers, um ein Objekt zwischen zwei Transformationen zu halten*</span><span class="sxs-lookup"><span data-stu-id="83f9d-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="83f9d-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="83f9d-223">SurfaceMagnetism</span></span>

<span data-ttu-id="83f9d-224">[`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) funktioniert, indem ein Raycast auf eine festgelegte LayerMask von Oberflächen ausgeführt und das GameObject an diesem Kontaktpunkt platziert wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="83f9d-225">Der *Surface Normal Offset* (Offset zur Oberflächennormale) platziert das GameObject in einem festgelegten Abstand in Metern von der Oberfläche in Richtung der Normalen am Punkt des Auftreffens auf der Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="83f9d-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="83f9d-226">Umgekehrt platziert der *Surface Ray Offset* (Offset zum Oberflächenstrahl) das GameObject in einem festgelegten Abstand in Metern von der Oberfläche weg, aber in entgegengesetzter Richtung des ausgeführten Raycasts.</span><span class="sxs-lookup"><span data-stu-id="83f9d-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="83f9d-227">Wenn der Raycast also das Anvisieren des Benutzers ist, bewegt sich das GameObject näher entlang der Linie vom Punkt des Auftreffens auf der Oberfläche zur Kamera.</span><span class="sxs-lookup"><span data-stu-id="83f9d-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="83f9d-228">Der *Orientation Mode* (Ausrichtungsmodus) bestimmt den Typ der Drehung, die in Bezug auf die Normale auf der Oberfläche angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="83f9d-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="83f9d-229">*None* (Keine): Keine Drehung angewendet.</span><span class="sxs-lookup"><span data-stu-id="83f9d-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="83f9d-230">*TrackedTarget* (Verfolgtes Ziel): Das Objekt wird der verfolgten Transformation, die den Raycast steuert, zugewandt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="83f9d-231">*SurfaceNormal* (Oberflächennormale): Das Objekt wird auf Grundlage der Normalen am Punkt des Auftreffens auf der Oberfläche ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="83f9d-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="83f9d-232">*Blended* (Gemischt): Das Objekt wird basierend auf der Normalen am Punkt des Auftreffens auf der Oberfläche UND der verfolgten Transformation zugewandt ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="83f9d-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="83f9d-233">Um zu erzwingen, dass das zugeordnete GameObject in jedem anderen Modus als *None* vertikal bleibt, aktivieren Sie *Keep Orientation Vertical* (Ausrichtung vertikal halten).</span><span class="sxs-lookup"><span data-stu-id="83f9d-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="83f9d-234">Verwenden Sie die Eigenschaft *Orientation Blend* (Gemischte Ausrichtung), um das Gleichgewicht zwischen Drehfaktoren zu steuern, wenn der *Orientation Mode* (Ausrichtungsmodus) auf *Blended* (Gemischt) festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="83f9d-235">Beim Wert 0,0 wird die Ausrichtung vollständig vom *TrackedTarget*-Modus gesteuert, und beim Wert 1,0 wird die Ausrichtung vollständig von *SurfaceNormal* gesteuert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![SurfaceMagnetism-Beispiel](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="83f9d-237">Bestimmen, welche Oberflächen erreicht werden können</span><span class="sxs-lookup"><span data-stu-id="83f9d-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="83f9d-238">Beim Hinzufügen einer [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism)-Komponente zu einem GameObject ist es wichtig, die Ebene des GameObject und seine untergeordneten Elemente zu berücksichtigen, sofern diese Collider aufweisen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="83f9d-239">Die Komponente funktioniert so, dass sie verschiedene Arten von Raycasts ausführt, um zu bestimmen, an welcher Oberfläche sie sich selbst „magnetisch anheften“ soll.</span><span class="sxs-lookup"><span data-stu-id="83f9d-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="83f9d-240">Wenn das Solver GameObject über einen Collider auf einer der Ebenen verfügt, die in der `MagneticSurfaces`-Eigenschaft von `SurfaceMagnetism` aufgeführt sind, trifft sich der Raycast wahrscheinlich selbst, was dazu führt, dass das GameObject an seinen eigenen Colliderpunkt angefügt wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="83f9d-241">Dieses seltsame Verhalten kann vermieden werden, indem das Haupt-GameObject und alle seine untergeordneten Elemente auf die *Ignore Raycast*-Eben (Raycast ignorieren) festgelegt werden oder das `MagneticSurfaces` LayerMask-Array entsprechend geändert wird.</span><span class="sxs-lookup"><span data-stu-id="83f9d-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="83f9d-242">Umgekehrt wird ein [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject nicht mit Oberflächen auf einer Ebene kollidieren, die nicht in der `MagneticSurfaces`-Eigenschaft aufgeführt ist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="83f9d-243">Es wird generell empfohlen, alle gewünschten Oberflächen auf einer dedizierten Ebene zu platzieren (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="83f9d-244">*Surfaces* (Oberflächen)) und die Eigenschaft `MagneticSurfaces` nur auf diese Ebene festzulegen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="83f9d-245">Die Verwendung von *default* (Standard) oder *everything* (alles) kann dazu führen, dass Benutzeroberflächenkomponenten oder Cursor zum Solver beitragen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="83f9d-246">Schließlich werden Oberflächen, die weiter als die Einstellung der Eigenschaft `MaxRaycastDistance` entfernt liegen, von den `SurfaceMagnetism`-Raycasts ignoriert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="83f9d-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="83f9d-247">DirectionalIndicator</span></span>

<span data-ttu-id="83f9d-248">Die [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)-Klasse ist eine Komponente mit Folgeverhalten, die sich selbst an der Richtung eines gewünschten Punkts im Raum orientiert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="83f9d-249">Wird am häufigsten verwendet, wenn der *Tracked Target Type* (Typ des verfolgten Ziels) des [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) auf [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="83f9d-250">Auf diese Weise weist eine UX-Komponente einen Benutzer mit dem [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)-Solver an, auf den gewünschten Punkt im Raum zu sehen.</span><span class="sxs-lookup"><span data-stu-id="83f9d-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="83f9d-251">Der gewünschte Punkt im Raum wird über die Eigenschaft *Directional Target* (Gerichtetes Ziel) bestimmt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="83f9d-252">Wenn das gerichtete Ziel für den Benutzer sichtbar ist, oder egal welcher Bezugsframe im [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) festgelegt ist, deaktiviert dieser Solver alle darunter liegenden [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html)-Komponenten.</span><span class="sxs-lookup"><span data-stu-id="83f9d-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="83f9d-253">Wenn es nicht sichtbar ist, wird alles für den Indikator aktiviert.</span><span class="sxs-lookup"><span data-stu-id="83f9d-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="83f9d-254">Der Indikator wird immer kleiner, je näher der Benutzer dem Erfassen des *Directional Target* in seinem Sichtfeld (FOV) kommt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="83f9d-255">*Min Indicator Scale* (Minimale Indikatorskala): Die minimale Skalierung für das Indikatorobjekt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="83f9d-256">*Max Indicator Scale* (Maximale Indikatorskala): Die maximale Skalierung für das Indikatorobjekt.</span><span class="sxs-lookup"><span data-stu-id="83f9d-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="83f9d-257">*Visibility Scale Factor* (Skalierungsfaktor für Sichtbarkeit): Multiplikator zum Erhöhen oder Verringern des Sichtfelds, der bestimmt, ob der Punkt des *Directional Target* sichtbar ist oder nicht.</span><span class="sxs-lookup"><span data-stu-id="83f9d-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="83f9d-258">*View Offset* (Sichtoffset): Aus der Sicht des Bezugsframes (d. h.</span><span class="sxs-lookup"><span data-stu-id="83f9d-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="83f9d-259">möglicherweise Kamera) definiert diese Eigenschaft, wie weit sich das Objekt in Indikatorrichtung von der Mitte des Viewports entfernt befinden soll.</span><span class="sxs-lookup"><span data-stu-id="83f9d-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="83f9d-260">![Directional Indicator-Eigenschaften (Richtungsindikator)](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="83f9d-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="83f9d-261">*Directional Indicator-Eigenschaften (Richtungsindikator)*</span><span class="sxs-lookup"><span data-stu-id="83f9d-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="83f9d-262">![Directional Indicator-Beispielszene (Richtungsindikator)](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="83f9d-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="83f9d-263">*Directional Indicator-Beispielszene (Richtungsindikator) (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="83f9d-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="83f9d-264">Handmenü mit HandConstraint und HandConstraintPalmUp</span><span class="sxs-lookup"><span data-stu-id="83f9d-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![UX-Beispiel für ein Handmenü](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="83f9d-266">Das [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint)-Verhalten stellt einen Solver bereit, der das verfolgte Objekt auf einen Bereich beschränkt, der für auf Hand eingeschränkte Inhalte sicher ist (z. B. Handbenutzeroberfläche, Menüs usw.).</span><span class="sxs-lookup"><span data-stu-id="83f9d-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="83f9d-267">Als sichere Regionen gelten Bereiche, die sich nicht mit der Hand überschneiden.</span><span class="sxs-lookup"><span data-stu-id="83f9d-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="83f9d-268">Eine abgeleitete Klasse von [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) namens [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) ist ebenfalls enthalten, um ein allgemeines Verhalten der Aktivierung des vom Solver verfolgten Objekts zu veranschaulichen, wenn die Handfläche dem Benutzer zugewandt ist.</span><span class="sxs-lookup"><span data-stu-id="83f9d-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="83f9d-269">Die Beispiele für die Verwendung des Handeinschränkungs-Solvers zum Erstellen von Handmenüs [finden Sie auf der Seite „Handmenü“](../hand-menu.md).</span><span class="sxs-lookup"><span data-stu-id="83f9d-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="83f9d-270">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="83f9d-270">See also</span></span>

* [<span data-ttu-id="83f9d-271">Hand-Tracking</span><span class="sxs-lookup"><span data-stu-id="83f9d-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="83f9d-272">Anvisieren</span><span class="sxs-lookup"><span data-stu-id="83f9d-272">Gaze</span></span>](../../input/gaze.md)
